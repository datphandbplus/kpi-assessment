"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoBuilder = void 0;
const lodash_1 = __importDefault(require("lodash"));
const sequelize_1 = require("sequelize");
const dialects_1 = require("./dialects/dialects");
const types_1 = require("./types");
class AutoBuilder {
    constructor(sequelize, tables, skipTables, schema, views) {
        this.sequelize = sequelize;
        this.queryInterface = this.sequelize.getQueryInterface();
        this.dialect = dialects_1.dialects[this.sequelize.getDialect()];
        this.includeTables = tables;
        this.skipTables = skipTables;
        this.schema = schema;
        this.views = !!views;
        this.tableData = new types_1.TableData();
    }
    build() {
        let prom;
        if (this.dialect.showTablesQuery) {
            const showTablesSql = this.dialect.showTablesQuery(this.schema);
            prom = this.sequelize.query(showTablesSql, {
                raw: true,
                type: sequelize_1.QueryTypes.SELECT
            });
        }
        else {
            prom = this.queryInterface.showAllTables();
        }
        if (this.views) {
            // Add views to the list of tables
            prom = prom.then(tr => {
                // in mysql, use database name instead of schema
                const vschema = this.dialect.name === 'mysql' ? this.sequelize.getDatabaseName() : this.schema;
                const showViewsSql = this.dialect.showViewsQuery(vschema);
                return this.sequelize.query(showViewsSql, {
                    raw: true,
                    type: sequelize_1.QueryTypes.SELECT
                }).then(tr2 => tr.concat(tr2));
            });
        }
        return prom.then(tr => this.processTables(tr))
            .catch(err => { console.error(err); return this.tableData; });
    }
    processTables(tableResult) {
        // tables is an array of either three things:
        // * objects with two properties table_name and table_schema
        // * objects with two properties tableName and tableSchema
        // * objects with a single name property
        // The first happens for dialects which support schemas (e.g. mssql, postgres).
        // The second happens for dialects which do not support schemas (e.g. sqlite).
        let tables = lodash_1.default.map(tableResult, t => {
            return {
                table_name: t.table_name || t.tableName || t.name || String(t),
                table_schema: t.table_schema || t.tableSchema || t.schema || this.schema || null
            };
        });
        // include/exclude tables
        if (this.includeTables) {
            const optables = mapOptionTables(this.includeTables, this.schema);
            tables = lodash_1.default.intersectionWith(tables, optables, isTableEqual);
        }
        else if (this.skipTables) {
            const skipTables = mapOptionTables(this.skipTables, this.schema);
            tables = lodash_1.default.differenceWith(tables, skipTables, isTableEqual);
        }
        const promises = tables.map(t => {
            return this.mapForeignKeys(t).then(() => this.mapTable(t));
        });
        return Promise.all(promises).then(() => this.tableData);
    }
    mapForeignKeys(table) {
        const tableQname = makeTableQName(table);
        const sql = this.dialect.getForeignKeysQuery(table.table_name, table.table_schema || this.sequelize.config.database);
        const dialect = this.dialect;
        const foreignKeys = this.tableData.foreignKeys;
        return this.sequelize.query(sql, {
            type: sequelize_1.QueryTypes.SELECT,
            raw: true
        }).then(res => {
            res.forEach(assignColumnDetails);
        }).catch(err => console.error(err));
        function assignColumnDetails(row, ix, rows) {
            let ref;
            if (dialect.remapForeignKeysRow) {
                ref = dialect.remapForeignKeysRow(table.table_name, row);
            }
            else {
                ref = row;
            }
            if (!lodash_1.default.isEmpty(lodash_1.default.trim(ref.source_column)) && !lodash_1.default.isEmpty(lodash_1.default.trim(ref.target_column))) {
                ref.isForeignKey = true;
                ref.foreignSources = lodash_1.default.pick(ref, ['source_table', 'source_schema', 'target_schema', 'target_table', 'source_column', 'target_column']);
            }
            if (dialect.isUnique && dialect.isUnique(ref, rows)) {
                ref.isUnique = ref.constraint_name || true;
            }
            if (lodash_1.default.isFunction(dialect.isPrimaryKey) && dialect.isPrimaryKey(ref)) {
                ref.isPrimaryKey = true;
            }
            if (dialect.isSerialKey && dialect.isSerialKey(ref)) {
                ref.isSerialKey = true;
            }
            foreignKeys[tableQname] = foreignKeys[tableQname] || {};
            foreignKeys[tableQname][ref.source_column] = lodash_1.default.assign({}, foreignKeys[tableQname][ref.source_column], ref);
        }
    }
    mapTable(table) {
        return this.queryInterface.describeTable(table.table_name, table.table_schema).then(fields => {
            this.tableData.tables[makeTableQName(table)] = fields;
            this.queryInterface.showIndex({ tableName: table.table_name, schema: table.table_schema }).then(inxs => {
                this.tableData.indexes[makeTableQName(table)] = inxs;
            });
            const countTriggerSql = this.dialect.countTriggerQuery(table.table_name, table.table_schema || "");
            return this.sequelize.query(countTriggerSql, {
                raw: true,
                type: sequelize_1.QueryTypes.SELECT,
            }).then((triggerResult) => {
                const triggerCount = parseInt(triggerResult && triggerResult[0] && triggerResult[0].trigger_count);
                if (triggerCount > 0) {
                    this.tableData.hasTriggerTables[makeTableQName(table)] = true;
                }
            });
        }).catch(err => console.error(err));
    }
}
exports.AutoBuilder = AutoBuilder;
// option tables are a list of strings; each string is either
// table name (e.g. "Customer") or schema dot table name (e.g. "dbo.Customer")
function mapOptionTables(arr, defaultSchema) {
    return lodash_1.default.map(arr, (t) => {
        const sp = t.split('.');
        return {
            table_name: sp[sp.length - 1],
            table_schema: sp.length > 1 ? sp[sp.length - 2] : defaultSchema
        };
    });
}
function isTableEqual(a, b) {
    return a.table_name === b.table_name && (!b.table_schema || a.table_schema === b.table_schema);
}
function makeTableQName(table) {
    return [table.table_schema, table.table_name].filter(Boolean).join(".");
}
//# sourceMappingURL=auto-builder.js.map