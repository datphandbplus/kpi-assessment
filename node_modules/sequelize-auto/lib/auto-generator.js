"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoGenerator = void 0;
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("./types");
class AutoGenerator {
    constructor(tableData, dialect, options) {
        this.tables = tableData.tables;
        this.foreignKeys = tableData.foreignKeys;
        this.hasTriggerTables = tableData.hasTriggerTables;
        this.indexes = tableData.indexes;
        this.dialect = dialect;
        this.options = options;
        this.options.lang = this.options.lang || 'es5';
        // build the space array of indentation strings
        let sp = '';
        for (let x = 0; x < (this.options.indentation || 2); ++x) {
            sp += (this.options.spaces === true ? ' ' : "\t");
        }
        this.space = [];
        for (let i = 0; i < 6; i++) {
            this.space[i] = sp.repeat(i);
        }
    }
    makeHeaderTemplate() {
        let header = "/* jshint indent: " + this.options.indentation + " */\n\n";
        const sp = this.space[1];
        if (this.options.lang === 'ts') {
            header += "import { DataTypes, Model, Sequelize } from 'sequelize';\n\n";
        }
        else if (this.options.lang === 'es6') {
            header += "const Sequelize = require('sequelize');\n";
            header += "module.exports = (sequelize, DataTypes) => {\n";
            header += sp + "return #TABLE#.init(sequelize, DataTypes);\n";
            header += "}\n\n";
            header += "class #TABLE# extends Sequelize.Model {\n";
            header += sp + "static init(sequelize, DataTypes) {\n";
            header += sp + "super.init({\n";
        }
        else if (this.options.lang === 'esm') {
            header += "import { Model, Sequelize } from 'sequelize';\n\n";
            header += "export default class #TABLE# extends Model {\n";
            header += sp + "static init(sequelize, DataTypes) {\n";
            header += sp + "super.init({\n";
        }
        else {
            header += "const Sequelize = require('sequelize');\n";
            header += "module.exports = function(sequelize, DataTypes) {\n";
            header += sp + "return sequelize.define('#TABLE#', {\n";
        }
        return header;
    }
    generateText() {
        const tableNames = lodash_1.default.keys(this.tables);
        const header = this.makeHeaderTemplate();
        const text = {};
        tableNames.forEach(table => {
            let str = header;
            const [schemaName, tableNameOrig] = types_1.qNameSplit(table);
            const tableName = types_1.recase(this.options.caseModel, tableNameOrig);
            if (this.options.lang === 'ts') {
                str += "export interface #TABLE#Attributes {\n";
                str += this.addTypeScriptFields(table) + "}\n\n";
                // str += "export interface #TABLE#CreationAttributes extends Optional<#TABLE#Attributes, 'Id'> {}\n\n";
                str += "export class #TABLE# extends Model<#TABLE#Attributes, #TABLE#Attributes> implements #TABLE#Attributes {\n";
                str += this.addTypeScriptFields(table);
                str += "\n" + this.space[1] + "static initModel(sequelize: Sequelize) {\n";
                str += this.space[2] + tableName + ".init({\n";
            }
            str += this.addTable(table);
            const re = new RegExp('#TABLE#', 'g');
            str = str.replace(re, tableName);
            text[table] = str;
        });
        return text;
    }
    // Create a string for the model of the table
    addTable(table) {
        const [schemaName, tableNameOrig] = types_1.qNameSplit(table);
        const tableName = types_1.recase(this.options.caseModel, tableNameOrig);
        const space = this.space;
        let timestamps = (this.options.additional && this.options.additional.timestamps === true) || false;
        let paranoid = false;
        // add all the fields
        let str = '';
        const fields = lodash_1.default.keys(this.tables[table]);
        fields.forEach((field, index) => {
            timestamps || (timestamps = this.isTimestampField(field));
            paranoid || (paranoid = this.isParanoidField(field));
            str += this.addField(table, field);
        });
        // trim off last ",\n"
        str = str.substring(0, str.length - 2) + "\n";
        // add the table options
        str += space[1] + "}, {\n";
        str += space[2] + "sequelize,\n";
        str += space[2] + "tableName: '" + tableNameOrig + "',\n";
        if (schemaName) {
            str += space[2] + "schema: '" + schemaName + "',\n";
        }
        if (this.hasTriggerTables[table]) {
            str += space[2] + "hasTrigger: true,\n";
        }
        str += space[2] + "timestamps: " + timestamps + ",\n";
        if (paranoid) {
            str += space[2] + "paranoid: true,\n";
        }
        // conditionally add additional options
        const hasadditional = lodash_1.default.isObject(this.options.additional) && lodash_1.default.keys(this.options.additional).length > 0;
        if (hasadditional) {
            lodash_1.default.each(this.options.additional, (value, key) => {
                if (key === 'name') {
                    // name: true - preserve table name always
                    str += space[2] + "name: {\n";
                    str += space[3] + "singular: '" + table + "',\n";
                    str += space[3] + "plural: '" + table + "'\n";
                    str += space[2] + "},\n";
                }
                else if (key === "timestamps" || key === "paranoid") {
                    // handled above
                }
                else {
                    value = lodash_1.default.isBoolean(value) ? value : ("'" + value + "'");
                    str += space[2] + key + ": " + value + ",\n";
                }
            });
        }
        // add indexes
        str += this.addIndexes(table);
        str = space[2] + str.trim();
        str = str.substring(0, str.length - 1);
        str += "\n" + space[1] + "}";
        str += ");\n";
        const lang = this.options.lang;
        if (lang === 'es6' || lang === 'esm' || lang === 'ts') {
            str += space[1] + "return " + tableName + ";\n";
            str += space[1] + "}\n}\n";
        }
        else {
            str += "};\n";
        }
        return str;
    }
    // Create a string containing field attributes (type, defaultValue, etc.)
    addField(table, field) {
        // ignore Sequelize standard fields
        const additional = this.options.additional;
        if (additional && (additional.timestamps !== false) && (this.isTimestampField(field) || this.isParanoidField(field))) {
            return '';
        }
        // Find foreign key
        const foreignKey = this.foreignKeys[table] && this.foreignKeys[table][field] ? this.foreignKeys[table][field] : null;
        const fieldObj = this.tables[table][field];
        if (lodash_1.default.isObject(foreignKey)) {
            fieldObj.foreignKey = foreignKey;
        }
        const fieldName = types_1.recase(this.options.caseProp, field);
        let str = this.quoteName(fieldName) + ": {\n";
        let defaultVal = fieldObj.defaultValue;
        const quoteWrapper = '"';
        // ENUMs for postgres...
        if (fieldObj.type === "USER-DEFINED" && !!fieldObj.special) {
            fieldObj.type = "ENUM(" + fieldObj.special.map(function (f) {
                return quoteWrapper + f + quoteWrapper;
            }).join(',') + ")";
        }
        const unique = fieldObj.unique || fieldObj.foreignKey && fieldObj.foreignKey.isUnique;
        const isSerialKey = lodash_1.default.isFunction(this.dialect.isSerialKey) &&
            (this.dialect.isSerialKey(fieldObj) ||
                (fieldObj.foreignKey && this.dialect.isSerialKey(fieldObj.foreignKey)));
        let wroteAutoIncrement = false;
        const space = this.space;
        // column's attributes
        const fieldAttrs = lodash_1.default.keys(fieldObj);
        fieldAttrs.forEach(attr => {
            // We don't need the special attribute from postgresql; "unique" is handled separately
            if (attr === "special" || attr === "unique") {
                return true;
            }
            if (isSerialKey && !wroteAutoIncrement) {
                str += space[3] + "autoIncrement: true,\n";
                wroteAutoIncrement = true;
            }
            if (attr === "foreignKey") {
                if (foreignKey && foreignKey.isForeignKey) {
                    str += space[3] + "references: {\n";
                    if (this.options.schema) {
                        str += space[4] + "model: {\n";
                        str += space[5] + "tableName: \'" + fieldObj[attr].foreignSources.target_table + "\',\n";
                        str += space[5] + "schema: \'" + fieldObj[attr].foreignSources.target_schema + "\'\n";
                        str += space[4] + "},\n";
                    }
                    else {
                        str += space[4] + "model: \'" + fieldObj[attr].foreignSources.target_table + "\',\n";
                    }
                    str += space[4] + "key: \'" + fieldObj[attr].foreignSources.target_column + "\'\n";
                    str += space[3] + "}";
                }
                else {
                    return true;
                }
            }
            else if (attr === "references") {
                // covered by foreignKey
                return true;
            }
            else if (attr === "primaryKey") {
                if (fieldObj[attr] === true && (!lodash_1.default.has(fieldObj, 'foreignKey') || !!fieldObj.foreignKey.isPrimaryKey)) {
                    str += space[3] + "primaryKey: true";
                }
                else {
                    return true;
                }
            }
            else if (attr === "autoIncrement") {
                if (fieldObj[attr] === true && !wroteAutoIncrement) {
                    str += space[3] + "autoIncrement: true,\n";
                    wroteAutoIncrement = true;
                }
                return true;
            }
            else if (attr === "allowNull") {
                str += space[3] + attr + ": " + fieldObj[attr];
            }
            else if (attr === "defaultValue") {
                const localName = fieldName;
                if (this.dialect.name === "mssql" && defaultVal && defaultVal.toLowerCase() === '(newid())') {
                    defaultVal = null; // disable adding "default value" attribute for UUID fields if generating for MS SQL
                }
                if (defaultVal === null || defaultVal === undefined) {
                    return true;
                }
                if (isSerialKey) {
                    return true; // value generated in the database
                }
                let val_text = defaultVal;
                if (lodash_1.default.isString(defaultVal)) {
                    const field_type = fieldObj.type.toLowerCase();
                    if (field_type === 'bit(1)' || field_type === 'bit' || field_type === 'boolean') {
                        // convert string to boolean
                        val_text = /1|true/i.test(defaultVal) ? "true" : "false";
                    }
                    else if (field_type === 'array') {
                        // change postgres array default '{}' to []
                        val_text = defaultVal.replace('{', '[').replace('}', ']');
                    }
                    else if (this.isNumber(field_type) || field_type.match(/^(json)/)) {
                        // remove () around mssql numeric values; don't quote numbers or json
                        val_text = defaultVal.replace(/[)(]/g, '');
                    }
                    else if (field_type === 'uuid' && (defaultVal === 'gen_random_uuid()' || defaultVal === 'uuid_generate_v4()')) {
                        val_text = "DataTypes.UUIDV4";
                    }
                    else if (lodash_1.default.endsWith(defaultVal, '()') || lodash_1.default.endsWith(defaultVal, '())')) {
                        // wrap default value function
                        val_text = "Sequelize.fn('" + defaultVal.replace(/[)(]/g, "") + "')";
                    }
                    else if (field_type.indexOf('date') === 0 || field_type.indexOf('timestamp') === 0) {
                        if (lodash_1.default.includes(['current_timestamp', 'current_date', 'current_time', 'localtime', 'localtimestamp'], defaultVal.toLowerCase())) {
                            val_text = "Sequelize.literal('" + defaultVal + "')";
                        }
                        else {
                            val_text = quoteWrapper + defaultVal + quoteWrapper;
                        }
                    }
                    else {
                        val_text = quoteWrapper + defaultVal + quoteWrapper;
                    }
                }
                // val_text = _.isString(val_text) && !val_text.match(/^sequelize\.[^(]+\(.*\)$/)
                // ? self.sequelize.escape(_.trim(val_text, '"'), null, self.options.dialect)
                // : val_text;
                // don't prepend N for MSSQL when building models...
                // defaultVal = _.trimStart(defaultVal, 'N');
                str += space[3] + attr + ": " + val_text;
            }
            else if (attr === "type" && fieldObj[attr].indexOf('ENUM') === 0) {
                str += space[3] + attr + ": DataTypes." + fieldObj[attr];
            }
            else if (attr === "comment" && !fieldObj[attr]) {
                return true;
            }
            else {
                let val = this.getSqType(fieldObj, attr);
                if (val == null) {
                    val = fieldObj[attr];
                    val = lodash_1.default.isString(val) ? quoteWrapper + this.escapeSpecial(val) + quoteWrapper : val;
                }
                str += space[3] + attr + ": " + val;
            }
            str += ",\n";
        });
        if (unique) {
            const uniq = lodash_1.default.isString(unique) ? quoteWrapper + unique.replace(/\"/g, '\\"') + quoteWrapper : unique;
            str += space[3] + "unique: " + uniq + ",\n";
        }
        if (field !== fieldName) {
            str += space[3] + "field: '" + field + "',\n";
        }
        // removes the last `,` within the attribute options
        str = str.trim().replace(/,+$/, '') + "\n";
        str = space[2] + str + space[2] + "},\n";
        return str;
    }
    addIndexes(table) {
        const indexes = this.indexes[table];
        const space = this.space;
        let str = "";
        if (indexes && indexes.length) {
            str += space[2] + "indexes: [\n";
            indexes.forEach(idx => {
                str += space[3] + "{\n";
                if (idx.name) {
                    str += space[4] + `name: "${idx.name}",\n`;
                }
                if (idx.unique) {
                    str += space[4] + "unique: true,\n";
                }
                if (idx.type) {
                    if (['UNIQUE', 'FULLTEXT', 'SPATIAL'].includes(idx.type)) {
                        str += space[4] + `type: "${idx.type}",\n`;
                    }
                    else {
                        str += space[4] + `using: "${idx.type}",\n`;
                    }
                }
                str += space[4] + `fields: [\n`;
                idx.fields.forEach(ff => {
                    str += space[5] + `{ name: "${ff.attribute}"`;
                    if (ff.collate) {
                        str += `, collate: "${ff.collate}"`;
                    }
                    if (ff.length) {
                        str += `, length: ${ff.length}`;
                    }
                    if (ff.order && ff.order !== "ASC") {
                        str += `, order: "${ff.order}"`;
                    }
                    str += " },\n";
                });
                str += space[4] + "]\n";
                str += space[3] + "},\n";
            });
            str += space[2] + "],\n";
        }
        return str;
    }
    /** Get the sequelize type from the Field */
    getSqType(fieldObj, attr) {
        const attrValue = fieldObj[attr];
        if (!attrValue.toLowerCase) {
            console.log("attrValue", attr, attrValue);
            return attrValue;
        }
        const type = attrValue.toLowerCase();
        const length = type.match(/\(\d+\)/);
        let val = null;
        if (type === "boolean" || type === "bit(1)" || type === "bit") {
            val = 'DataTypes.BOOLEAN';
        }
        else if (type.match(/^(smallint|mediumint|tinyint|int)/)) {
            val = 'DataTypes.INTEGER' + (!lodash_1.default.isNull(length) ? length : '');
            if (/unsigned/i.test(type)) {
                val += '.UNSIGNED';
            }
            if (/zerofill/i.test(type)) {
                val += '.ZEROFILL';
            }
        }
        else if (type.match(/^bigint/)) {
            val = 'DataTypes.BIGINT';
        }
        else if (type.match(/^n?varchar/)) {
            val = 'DataTypes.STRING' + (!lodash_1.default.isNull(length) ? length : '');
        }
        else if (type.match(/^string|varying|nvarchar/)) {
            val = 'DataTypes.STRING';
        }
        else if (type.match(/^n?char/)) {
            val = 'DataTypes.CHAR' + (!lodash_1.default.isNull(length) ? length : '');
        }
        else if (type.match(/^real/)) {
            val = 'DataTypes.REAL';
        }
        else if (type.match(/text$/)) {
            val = 'DataTypes.TEXT' + (!lodash_1.default.isNull(length) ? length : '');
        }
        else if (type === "date") {
            val = 'DataTypes.DATEONLY';
        }
        else if (type.match(/^(date|timestamp)/)) {
            val = 'DataTypes.DATE' + (!lodash_1.default.isNull(length) ? length : '');
        }
        else if (type.match(/^(time)/)) {
            val = 'DataTypes.TIME'; // + (!_.isNull(length) ? length : '');
        }
        else if (type.match(/^(float|float4)/)) {
            val = 'DataTypes.FLOAT';
        }
        else if (type.match(/^decimal/)) {
            val = 'DataTypes.DECIMAL';
        }
        else if (type.match(/^money/)) {
            val = 'DataTypes.DECIMAL(19,4)';
        }
        else if (type.match(/^smallmoney/)) {
            val = 'DataTypes.DECIMAL(10,4)';
        }
        else if (type.match(/^(float8|double|numeric)/)) {
            val = 'DataTypes.DOUBLE';
        }
        else if (type.match(/^uuid|uniqueidentifier/)) {
            val = 'DataTypes.UUID';
        }
        else if (type.match(/^jsonb/)) {
            val = 'DataTypes.JSONB';
        }
        else if (type.match(/^json/)) {
            val = 'DataTypes.JSON';
        }
        else if (type.match(/^geometry/)) {
            val = 'DataTypes.GEOMETRY';
        }
        else if (type.match(/^geography/)) {
            val = "DataTypes.GEOGRAPHY('POINT', 4326)";
        }
        else if (type.match(/^array/)) {
            val = 'DataTypes.ARRAY';
        }
        else if (type.match(/^(varbinary|image)/)) {
            val = 'DataTypes.BLOB';
        }
        else if (type.match(/^hstore/)) {
            val = 'DataTypes.HSTORE';
        }
        return val;
    }
    addTypeScriptFields(table) {
        const sp = this.space[1];
        const fields = lodash_1.default.keys(this.tables[table]);
        let str = '';
        fields.forEach(field => {
            const name = this.quoteName(types_1.recase(this.options.caseProp, field));
            str += `${sp}${name}?: ${this.getTypeScriptType(table, field)};\n`;
        });
        return str;
    }
    getTypeScriptType(table, field) {
        const fieldObj = this.tables[table][field];
        const fieldType = (fieldObj["type"] || '').toLowerCase();
        let jsType;
        if (this.isString(fieldType)) {
            jsType = 'string';
        }
        else if (this.isNumber(fieldType)) {
            jsType = 'number';
        }
        else if (this.isBoolean(fieldType)) {
            jsType = 'boolean';
        }
        else if (this.isDate(fieldType)) {
            jsType = 'Date';
        }
        else if (this.isArray(fieldType)) {
            jsType = 'any[]';
        }
        else {
            console.log(`Missing type: ${fieldType}`);
            jsType = 'any';
        }
        return jsType;
    }
    isTimestampField(field) {
        const additional = this.options.additional;
        if (additional.timestamps === false) {
            return false;
        }
        return ((!additional.createdAt && field.toLowerCase() === 'createdat') || additional.createdAt === field)
            || ((!additional.updatedAt && field.toLowerCase() === 'updatedat') || additional.updatedAt === field);
    }
    isParanoidField(field) {
        const additional = this.options.additional;
        if (additional.timestamps === false || additional.paranoid === false) {
            return false;
        }
        return ((!additional.deletedAt && field.toLowerCase() === 'deletedat') || additional.deletedAt === field);
    }
    escapeSpecial(val) {
        if (typeof (val) !== "string") {
            return val;
        }
        return val
            .replace(/[\\]/g, '\\\\')
            .replace(/[\"]/g, '\\"')
            .replace(/[\/]/g, '\\/')
            .replace(/[\b]/g, '\\b')
            .replace(/[\f]/g, '\\f')
            .replace(/[\n]/g, '\\n')
            .replace(/[\r]/g, '\\r')
            .replace(/[\t]/g, '\\t');
    }
    /** Quote the name if it is not a valid identifier */
    quoteName(name) {
        return (/^[$A-Z_][0-9A-Z_$]*$/i.test(name) ? name : "'" + name + "'");
    }
    isNumber(fieldType) {
        return /^(smallint|mediumint|tinyint|int|bigint|float|money|smallmoney|double|decimal|numeric|real)/.test(fieldType);
    }
    isBoolean(fieldType) {
        return /^(boolean|bit)/.test(fieldType);
    }
    isDate(fieldType) {
        return /^(date|time|timestamp)/.test(fieldType);
    }
    isString(fieldType) {
        return /^(char|nchar|string|varying|varchar|nvarchar|text|longtext|mediumtext|tinytext|ntext|uuid|uniqueidentifier)/.test(fieldType);
    }
    isArray(fieldType) {
        return /^(array)/.test(fieldType);
    }
}
exports.AutoGenerator = AutoGenerator;
//# sourceMappingURL=auto-generator.js.map